******************
Опции и исключения
******************

Все расчеты цен, изменения картинок, SKU, дополнительной информации о товаре теперь происходит не на уровне JS, а на уровне PHP. 

Создано 2 типа обработки запроса расчета информации о товаре:

* Товары со страницы категории, детальной страницы товара или же пикеров.

* Товары со страницы корзины или модули оформления заказа, например *Gift registry* или *Wishlist* обрабатывают эти запросы самостоятельно (подробнее см. в разделе "Взаимодействие с другими модулями").

Когда пользователь выбирает опцию, происходит перерасчет цен и т.п. 

Исключение составляют последовательные опции: только после выбора первой опции, следующая за ней будет заполнена значениями. До этого будет отображено *n/a*.

=================================
Взаимодейтсвие с другими модулями
=================================

* **Wishlist addon** — был создан контроллер ``product.pre.php``. Он обрабатывает входящий запрос, применяя все изменения именно к корзине wishlist и делая перерасчет цен.

* **Product configurator** — был создан контроллер ``product.pre.php``. Он обрабатывает входящий запрос, применяя все изменения к конфигурируемому товару и делая перерасчет цен.

* **Gift registry** — был создан контроллер ``product.pre.php``. Он обрабатывает входящий запрос, применяя все изменения к товарам в событии и делая перерасчет цен.

* **Buy together** — в пикере, который появляется для выбора доп. опций для товаров в списке, учитываются исключения и последовательные опции.

======================
Программная реализация
======================

---
PHP
---

Все основные вычисления выполняются в файле ``controllers/common/products.post.php``. По входящим данным мы можем определить, производится ли расчет цен для товара в категории (детальной странице или же пикере), либо же для товаров в корзине.

* Для первого типа расчетов все понятно. Получаем информацию о товаре, его выбранные опции, а также опцию, которая была изменена (необходимо для последовательных опций). В функции ``fn_gather_additional_product_data`` мы получаем его новую цену, SKU, картинки и тд. А также получаем новый список опций, учитывая последовательные опции и исключения.

* Второй тип расчетов посложнее. Фукнционал здесь похож на обновление товаров в корзине. Пришла информация, обновили в корзине, вывели для получения результата. Но есть одна загвоздка, при изменении опций у товара в корзине, так же менялись и ``cart_id`` товара, а следовательно и ID всех элементов также менялись, что вызывало ошибку обновления данных (ничего не изменялось для пользователя, хотя опции были изменены). Для этого был введен параметр ``object_id``, при помощи которого мы возвращали в исходное состояние ``cart_id`` товара после его перерасчета.

-------
Шаблоны
-------

Для того, чтобы нам знать, какие блоки должны быть обновлены, при изменении опций, используется класс ``cm-reload-#ID``, где ID - уникальный ID товара.

Все блоки располагаются в ``common_tempaltes/product_data.tpl``.

**Пример:**

::

  <html>
  <span class="cm-reload-{$obj_prefix}{$obj_id}" id="product_features_update_{$obj_prefix}{$obj_id}">
      <input type="hidden" name="appearance[show_features]" value="{$show_features}" />
      {include file="views/products/components/product_features_short_list.tpl" features=$product.product_id|fn_get_product_features_list|escape no_container=true}
  <!--product_features_update_{$obj_prefix}{$obj_id}--></span>
  </html>

Это означает, что этот блок будет обновлен. Каждый такой блок должен иметь уникальный ID, который обязательно должен заканчиваться на ``_update_#ID``. Постфикс ``_update`` был добавлен для того, чтобы корректно выбирать данные только из обновляемых блоков этого товара, а не все ``input`` элементы на странице.

Поскольку разные шаблоны используют свои стили отображения товара (категории, лейауты, пикеры и тд), и у каждого свои настройки, был введен параметр ``appearance``.

**Пример:**

::

  <html>
  <input type="hidden" name="appearance[show_add_to_cart]" value="{$show_add_to_cart}" />
  </html>

Тем самым, при перерасчете опций мы получим именно те значения этих параметров, которые были использованы для отображения элементов у пользователя. Все параметры в массиве ``appearance`` передадутся в smarty после пересчета показателей товара.

Аналогично дела обстоят с изображениями товара и его доп. картинками. Все картинки или блоки картинок помещаются в отдельные блоки, которые также выводятся после обновления информации о товаре.

При изменении опций все значения *checkbox* в блоке ``cm-reload`` изменяются на ``checked`` и ``unchecked``, чтобы точно знать какие чекбоксы имееются в опциях и какие из них включены или выключены. 

Для того, чтобы значения оставались неизменные, например ``Y`` или ``N``, необходимо к чекбоксу добавить класс ``cm-no-change``. В этом случае, если чекбокс выбран (``checked``), то значение не изменится, в противном случае будет передано пустое значение.
