**********************************
Мультипоточность способов доставки
**********************************

================
Основные моменты
================

Реализация основана на использовании библиотеки ``CURL``. Если функции мультипоточных запросов ``CURL`` (``curl_multi_*()``) недоступны, запросы происходят в последовательном режиме. Если модуль шиппинга не поддерживает параллельность (текущая реализация FedEx, SwissPost), работа с этим сервисом также просходит в обычном, последовательном режиме. При этом никаких изменений в архитектуре модуля не требуется. При проверке настройки шиппинга используется доступный сервисом режим.

=======================================================================
Реализация многопоточности и архитектура многопоточного модуля шиппинга
=======================================================================

Управление сервисами осуществляется классом ``RealtimeServices.php``.

Каждый сервис должен использовать интерфейс **IService.php** (*app/Tygh/Shippings/IService.php*).

И реализовывать следующие методы:

* ``prepareData``
* ``processResponse``
* ``processErrors``
* ``allowMultithreading``
* ``getRequestData``
* ``getSimpleRates``

Описание методов и входных параметров смотреть в файле **ISerivce.php**.

При возможности мультипоточности (сервер позволяет и позволяет сам сервис), будет вызван метод ``getRequestData``, который должен вернуть массив следующего содержания:

::

  return array(
      'method' => 'post', // post,get
      'url' => $url, // URL шиннинг сервиса, например: "https://wwwcie.ups.com:443/ups.app/xml/Rate"
      'data' => $request, // Данные, которые нужно отправить шиппинг сервису
      'headers' => array( // Не обязательный параметр. Дополнительные заголовки
          'Content-type: text/xml' 
      )
  );

После этого класс ``RealtimeServices`` добавит его в стек запросов. И выполнит их после обработки всех сервисов.
После завершения запроса запустится callback метод ``processResponse``, который должен вернуть массив:

::

  $return = array(  
      'cost' => false, // false - если не удалось получить цену или float число, например 3.45  
      'error' => false, // false - если не было ошибок или string, если была. Например: 
                        // "Destination zipcode is incorrect"  
  );  

Если мультипоточность недоступна, то выполнится метод ``getSimpleRates``. Обычно он так же выполняет ``getSimpleRates`` и запускает:

::

  Http::post($data['url'], $data['data'], array('headers' => 'Content-type: text/xml'));

Должен вернуть ответ сервера. НЕ парсить его *processResponse*. Эта фукнция будет выполнена автоматически.

Тем самым, реализация мультипоточности происходит в классе ``RealtimeServices``.
