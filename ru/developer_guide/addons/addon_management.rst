****************************************************
Установка, удаление, активация и деактивация модулей
****************************************************

===========================================================
Построение списка модулей на странице "Управление модулями"
===========================================================

1. Генерируется предварительный список модулей на основе содержимого директории *app/addons*. Каждая подпапка считается модулем.

2. Для каждой папки делается попытка загрузить **app/addons/[addon]/addon.xml**. Если загрузка не удалась, или xml не читается, то модуль игнорируется. При этом ошибки чтения самого **addon.xml** будут выведены в Error notice.

3. Для всех оставшихся модулей берется имя модуля. Для актуальной :doc:`схемы 3.0 <scheme/scheme3.0_structure>` название модуля берется из PO-файла *var/langs/[lang_code]/addons/[addon].po*.

4. Данные уже установленных модулей берутся из БД и накатываются поверх списка неустановленных модулей. Т.е. если модуль уже установлен, изменение его имени или описания не применится.

.. _ru-install-addon-process:

========================
Процесс установки модуля
========================

1. Убеждаемся, что в таблице ``?:addons`` нет записи для модуля.

2. Загружаем схему модуля из **addon.xml**.

3. Если модуль помечен как ``unmanaged``, установку разрешается продолжить только в консольном режиме.

4. В автозагрузчик классов ``Tygh::$app['class_loader']`` добавляем папку с модулем, чтобы работала автозагрузка классов модуля.

5. Производится :doc:`проверка совместимости <scheme/addon_compatibility>`.

   .. note::

       Если какая-либо проверка провалилась, то выводится текст ошибки и установка модуля прерывается.
 
6. Производится проверка зависимостей необходимых модулей.

   .. note::
        
       Конфликтные модули на этом этапе не проверяются, они будут проверяться при :ref:`активации модуля <ru-activate-addon-process>`.
    
7. Выполняются функции, заданные в разделе ``<functions>`` с ``for="before_install"``.

    .. note::

        Если в процессе выполнения функции была вызвана ошибка БД, то установка прекращается и запускается :ref:`удаление модуля <ru-uninstall-addon-process>`.

8. Создается запись в ``Registry::set('addons.' . $addon)`` в которую записывается только статус ``disabled`` и приоритет модуля.
    
9. Выполняются запросы из секции ``<queries>`` с ``for="install"``.

    .. note::

         При ошибке БД установка прекращается и запускается :ref:`удаление модуля <ru-uninstall-addon-process>`.

10. В БД создаются настройки (``секция <settings>``).

    .. note::

         При ошибке БД установка прекращается и запускается :ref:`удаление модуля <ru-uninstall-addon-process>`.

11. Создаются записи в таблицах ``?:addons`` и ``?:addon_descriptions``, при этом модулю пока ставится статус ``disabled`` (*Выкл.*).

12. Устанавливаются языковые переменные из PO-файла.

13. Устанавливаются шаблоны: копируются из *var/themes_repository* в *design/themes*.

14. В ``Registry::set('addons.' . $addon)`` и в ``Registry::set('settings.' . $addon, $settings)`` записываются значения настроек модуля.

15. Английские значения языковых переменных сохраняются в таблицу ``?:original_values``.

16. Производится установка product tabs на основе директории *[theme]/templates/addons/[addon]/blocks/product_tabs*.

17. Выполняются функции, заданные в разделе ``<functions>`` с ``for="install"``.

    .. note::

        Если в процессе выполнения функции была вызвана ошибка БД, то установка прекращается и запускается :ref:`удаление модуля <ru-uninstall-addon-process>`.

18. Производится :ref:`активация модуля <ru-activate-addon-process>`, если в **addon.xml** статус модуля задан как *Active*.

    .. note::

        Если активация провалилась, то модуль остается установленным, просто он останется выключен по умолчанию. При этом процесс установки продолжается.

19. Производится импорт макета: *app/addons/[addon]/layouts.xml*.

20.Очищается кэш магазина.

21. Устанавливаются демо-данные.

    .. note::
        
        Это происходит только в том случае, если модуль устанавливается в процессе установки магазина, и была выбрана опция установки демо-данных.

      .. note::

          При ошибке БД установка прекращается и запускается :ref:`удаление модуля <ru-uninstall-addon-process>`.

.. _ru-uninstall-addon-process:

=======================
Процесс удаления модуля
=======================

1. Если модуль помечен как ``unmanaged``, удаление разрешается продолжить только в консольном режиме.

2. Проверяется наличие других модулей, у которых текущий модуль указан :doc:`в качестве зависимости <scheme/addon_dependencies>`. Если такие модули найдены, то удаление прекращается и выводится ошибка: 

   .. important::

       Warning::The add-on cannot be uninstalled because the following add-ons depend on it: [addons]".

3. Выполняются функции, заданные в разделе ``<functions>`` с ``for="uninstall"``.

4. Удаляются записи из таблиц ``?:addons`` и ``?:addon_descriptions``.

5. Удаляются настройки модуля.

6. Удаляются языковые переменные модуля.

8. Выполняются запросы из секции ``<queries>`` с ``for="uninstall"``.
    
9. Удаляются product tabs модуля.

10. Удаляются шаблоны модуля из ``design/themes``.
    
11. Откатываются макеты модуля.
   
12. Очищается ``Registry::get('addons.' . $addon_name)``.

13. Удаляются хуки модуля из списка зарегистрированных хуков (``Registry::get('hooks')``).
    Очищается кэш магазина.

.. _ru-activate-addon-process:

========================
Процесс активации модуля
========================

1. Загружаем схему модуля из **addon.xml**.

2. Если модуль помечен как ``unmanaged``, активацию разрешается продолжить только в консольном режиме.

3. Запускается хук::

     fn_set_hook('update_addon_status_pre', $addon, $status, $show_notification, $on_install, $allow_unmanaged, $old_status, $scheme);

4. Производится первая часть проверки совместимости :doc:`конфликтных модулей <scheme/addon_compatibility>`: берем все активные модули на текущий момент и смотрим, не является ли наш модуль конклифтом для них.

   .. note::
        
       Если проверка провалилась, то выводится текст ошибки и активация прерывается.

5. Проверяется существование функции ``fn_settings_actions_addons_[addon]()``. Если функция существует, то она вызывается с аргументами: ``($new_status, $old_status, $on_install)``.

6. Производится вторая часть проверки совместимости :doc:`конфликтных модулей <scheme/addon_compatibility>`: убеждаемся что все модули, конфликтующие с нашим, выключены на текущий момент.

   .. note::
        
       Если проверка провалилась, то выводится текст ошибки и активация прерывается.

7. В базе в таблице ``?:addons`` меняется значение поля ``status`` у модуля на *A*.

8. Проверяется существование функции ``fn_settings_actions_addons_post_[addon]()``. Если функция существует, то она вызывается с аргументами: ``($new_status)``.

9. Производится обновление статусов product tabs: включаются product_tabs нашего модуля.

10. В ``Registry::set('addons.[addon].status')`` записывается новый статус *A*.

==========================
Процесс деактивации модуля
==========================

1. Загружаем схему модуля из **addon.xml**.

2. Если модуль помечен как ``unmanaged``, декативацию разрешается продолжить только в консольном режиме.
    
3. Запускается хук:: 

     fn_set_hook('update_addon_status_pre', $addon, $status, $show_notification, $on_install, $allow_unmanaged, $old_status, $scheme);

4. Проверяется существование функции ``fn_settings_actions_addons_[addon]()``. Если функция существует, то она вызывается с аргументами: ``($new_status, $old_status, $on_install)``.

5. В БД в таблице ``?:addons`` меняется значение поля **status** у модуля на *D*.

6. Проверяется существование функции ``fn_settings_actions_addons_post_[addon]()``. Если функция существует, то она вызывается с аргументами: ``($new_status)``.

7. Производится обновление статусов product tabs: выключаются product_tabs нашего модуля.
    
8. В ``Registry::set('addons.[addon].status')`` записывается новый статус *D*.
