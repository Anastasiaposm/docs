*****************************************
11. Сохранение данных настройки. Часть 1. 
*****************************************

Мы создали новую настройку (поле) для товара с помощью модуля. 

Проверим её работу. Вводим произвольный текст в поле «Код от видео с YouTube» и нажимаем кнопку «Сохранить».

.. fancybox:: img/howto_addon_22.png
    :alt: Первый модуль

Страница перезагрузилась, однако поле осталось пустым. 

Это логично, мы ничего не сделали, чтобы данные из поля сохранились в базе данных. 

Что нужно сделать? 

Изучим, что происходит после нажатия кнопки «Сохранить». 

1.  Открываем код кнопки «Сохранить» в браузере

    .. fancybox:: img/howto_addon_23.png
        :alt: Первый модуль

    .. image:: img/howto_addon_24.png
        :alt: Первый модуль

2.  Изучаем код и видим параметр ``data-ca-dispatch="dispatch[products.update]"``.

    Нас интересует: ``dispatch[products.update]``.

    ``products`` — название контроллера который будет обрабатывать запрос **products.php**.

    ``update`` — режим (mode), секция в контроллере с условием ``$mode == 'update'``.


3.  Открываем php файл — контроллер. 

    Все контроллеры панели администратора расположены в папке:

    ``/app/controllers/backend``

    Переходим и открываем файл **products.php** (название файла указано в параметре ``dispatch``).

    ``/app/controllers/backend/products.php``

4.  Вставляем гденибудь в начале php файла функцию ``fn_print_die('Проверка контроллера');``

    Например так: 

    .. literalinclude:: files/test_controller.php
        :emphasize-lines: 2
        :linenos:

5.  Возвращаемся на страницу редактирования товара, опять вводим что-нибудь в наше поле и нажимаем кнопку «Сохранить».

    Вы должны увидеть текст из функции ``fn_print_die``.

    .. image:: img/howto_addon_25.png
        :alt: Первый модуль

    Почему так? 

    a.  Контроллер найден правильно.

    б.  Функция ``fn_print_die`` распечатывает на экран переданные параметры и останавливает выполнение скрипта. Это очень удобно, потому что POST запросы заканчиваются редиректом и без остановки скрипта не получится изучить происходящее внутри. 


6.  Находим код отвечающий за обработку POST запросов.

    .. literalinclude:: files/test_controller_2.php
        :emphasize-lines: 2
        :linenos:

    .. note::

        Формы в панели администратора отправляются методом POST и обрабатываются в специальном блоке контроллера который обозначен условием ``if ($_SERVER['REQUEST_METHOD'] == 'POST')``. Чтобы не путаться, любой контроллер разделён логически на два блока:

        POST — отправка форм и обработка Ajax запросов. Всегда идёт первым. 

        GET — подготовка информации для отображения страницы.

        Больше о контроллерах вы можете изучить по ссылке: :doc:`Контроллеры </developer_guide/core/controllers/index>`.

7.  По параметру ``dispatch`` мы можем ещё более точно определить часть контроллера которая будет выполнять обработку формы. 

    Ещё раз взглянем на: ``dispatch[products.update]``

    ``update`` — режим (mode) работы который нам нужен. 

    Находим поиском по файлу условие ``if ($mode == 'update')`` и переносим туда функцию ``fn_print_die``.

    Чтобы получилось так:

    .. literalinclude:: files/test_controller_3.php
        :linenos:


    Проверяем в браузере, перезагрузив страницу. Должна появится контрольная фраза:

    .. image:: img/howto_addon_26.png
        :alt: Первый модуль

    Отлично найден раздел, который точно участвует в обработке данных из формы. Где то в этом разделе данные нашей настройки должны сохранится в базе данных.

    В следующим уроке мы найдём конкретное место сохранения данных.


